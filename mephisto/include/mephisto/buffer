#ifndef MEPHISTO_DETAIL_META
#define MEPHISTO_DETAIL_META
#include <alpaka/alpaka.hpp>

#include <mephisto/array>
#include <mephisto/type_traits>
#include <mephisto/util>
#include <type_traits>

#include <iostream>

#include <libdash.h>

namespace mephisto {


/**
 * Information about a local chunk of memory and its coordinates relative to
 * the global origin.
 */
template <std::size_t Dim>
struct Metadata {
  using dim_t = alpaka::dim::DimInt<Dim>;
  using vec_t = alpaka::vec::Vec<dim_t, std::size_t>;

private:
  vec_t _offsets;
  vec_t _extents;

public:
  ALPAKA_FN_HOST_ACC Metadata(vec_t offsets, vec_t extents)
    : _offsets(offsets)
    , _extents(extents)
  {
  }

  ALPAKA_FN_HOST Metadata(
      LocalArray<std::size_t, Dim> offsets,
      LocalArray<std::size_t, Dim> extents)
    : _offsets(
          alpaka::vec::createVecFromIndexedFnWorkaround<dim_t, std::size_t, arr_to_vec>(offsets))
    , _extents(
          alpaka::vec::createVecFromIndexedFnWorkaround<dim_t, std::size_t, arr_to_vec>(extents))
  {
  }

  ALPAKA_FN_HOST_ACC
  auto &offsets() const
  {
    return _offsets;
  }

  ALPAKA_FN_HOST_ACC
  auto &extents() const
  {
    return _extents;
  }

  ALPAKA_FN_HOST_ACC
  auto size() const
  {
    return _extents.sum();
  }
};

template <
    typename Element,
    typename Entity,
    std::size_t Dim,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(Element)>::type>
struct DeviceDataBuffer {
  using Meta     = Metadata<Dim>;
  using device_t = typename entity_traits::device<Entity>::type;
  using acc_t    = typename entity_traits::acc<Entity>::type;

  // We need to save the PlainPtr views here, so we don't have to keep an
  // instance of the device here, too.
  using meta_view_t = alpaka::mem::view::
      ViewPlainPtr<device_t, Meta, alpaka::dim::DimInt<1>, std::size_t>;
  using data_view_t = alpaka::mem::view::ViewPlainPtr<
      device_t,
      Element,
      alpaka::dim::DimInt<Dim>,
      std::size_t>;

  static constexpr size_t MetaOffset =
      sizeof(Meta) + sizeof(Meta) % Alignment::value;

  using buf_t = alpaka::mem::buf::Buf<device_t, char, alpaka::dim::DimInt<1>, std::size_t>;
  buf_t _buf;
  void *      _base;
  Element *   _data;
  std::size_t _entity_index;

  template <typename Buffer>
  DeviceDataBuffer(Entity ent, Buffer buf)
    : _buf(buf)
    , _base(alpaka::mem::view::getPtrNative(buf))
    , _entity_index(ent.index())
    , _data(reinterpret_cast<Element *>(
          reinterpret_cast<char *>(_base) + MetaOffset))
  {
  }

  
  buf_t& buf() {
    return _buf;
  }

  ALPAKA_FN_HOST_ACC
  Meta &meta()
  {
    // get the memory MetaOffset bytes before data
    return *reinterpret_cast<Meta *>(_base);
  }

  ALPAKA_FN_HOST
  meta_view_t meta_view()
  {
    return alpaka::mem::view::createStaticDevMemView(
        &meta(), entity().device(), static_cast<std::size_t>(1));
  }

  ALPAKA_FN_HOST
  data_view_t data_view()
  {
    return alpaka::mem::view::createStaticDevMemView(
        begin(), entity().device(), meta().extents());
  }

  /**
   * Returns the one-past-end pointer
   */
  ALPAKA_FN_HOST_ACC
  Element *begin() const
  {
    return _data;
  }

  /**
   * Returns the one-past-end pointer
   */
  ALPAKA_FN_HOST_ACC
  Element *end() const
  {
    return begin() + meta().size();
  }

  Entity entity() const
  {
    return Entity(_entity_index);
  }
};

/**
 * Data buffer is used to reduce the number of parameters to avoid hitting the
 * 256 byte limit.
 *
 * buf[[meta]..<padding>..[data...]]
 *
 */
template <
    typename Element,
    typename Device,
    std::size_t Dim,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(Element)>::type>
class HostDataBuffer {
  using NonConstElement = typename std::remove_const<Element>::type;
  using Host            = alpaka::dev::DevCpu;
  using Meta            = Metadata<Dim>;
  using DimInt          = alpaka::dim::DimInt<Dim>;
  using Idx             = std::size_t;
  using DeviceBuf =
      DeviceDataBuffer<NonConstElement, Device, Dim, Alignment>;
  using HostBuf =
      alpaka::mem::buf::Buf<Host, char, alpaka::dim::DimInt<1>, std::size_t>;

  static constexpr size_t MetaOffset =
      sizeof(Meta) + sizeof(Meta) % Alignment::value;

  Element *   _begin;
  std::size_t _nelems;
  std::size_t _bufsize;
  Meta        _meta;

public:
  template<typename Vec>
  HostDataBuffer(Vec viewspec, Element *begin)
    : _begin(begin)
    , _meta(viewspec.offsets(), viewspec.extents())
    , _nelems(viewspec.size())
    , _bufsize(sizeof(Meta) + _nelems * sizeof(Element) + Alignment::value)
  {
  }

  // TODO: extract into proper allocator?
  template <typename Entity>
  auto alloc_entity_buf(Entity &entity)
  {
    // Return a newly created and allocated buffer
    using buf_t = alpaka::mem::buf::Buf<
        decltype(entity.device()),
        char,
        alpaka::dim::DimInt<1>,
        std::size_t>;
    buf_t buf(alpaka::mem::buf::alloc<char, std::size_t>(
        entity.device(), _bufsize));
    return DeviceBuf{entity, std::move(buf)};
  }

  Meta &meta()
  {
    return _meta;
  }

  Element *data() const
  {
    return _begin;
  }

  Element *begin() const
  {
    return _begin;
  }

  auto host() const
  {
    return Host{alpaka::pltf::getDevByIdx<alpaka::pltf::PltfCpu>(0u)};
  }

  /* auto getDeviceMetaView() */
  /* { */
  /*   auto devicePtr = alpaka::mem::view::getPtrNative(deviceBuf); */
  /*   return alpaka::mem::view::ViewPlainPtr<Device, Meta, */
  /*                                          alpaka::dim::Dim<std::size_t>,
   */
  /*                                          alpaka::idx::Idx<std::size_t>>(
   */
  /*       reinterpret_cast<Meta *>(devicePtr), context.accDevice,
   * static_cast<std::size_t>(1)); */
  /* } */

  auto meta_view()
  {
    return alpaka::mem::view::createStaticDevMemView(
        &_meta, host(), static_cast<std::size_t>(1));
  }

  /* auto getDeviceDataView() */
  /* { */
  /* //, deviceBuf( */
  /*  //     alpaka::mem::buf::alloc<char, size_t>(context.accDevice,
   * bufsize)) */
  /*   return alpaka::mem::view::ViewPlainPtr<Device, NonConstElement, */
  /*                                          alpaka::dim::Dim<std::size_t>,
   */
  /*                                          alpaka::idx::Idx<std::size_t>>(
   */
  /*       reinterpret_cast<NonConstElement *>( */
  /*           reinterpret_cast<char *>( */
  /*               alpaka::mem::view::getPtrNative(deviceBuf)) + */
  /*           MetaOffset), */
  /*       context.accDevice, static_cast<std::size_t>(datasize)); */
  /* } */

  HostBuf data_view()
  {
    return alpaka::mem::view::createStaticDevMemView(
        data(), host(), _meta.extents());
  }

  size_t datasize() const
  {
    return _nelems * sizeof(Element);
  }

  size_t nelems() const
  {
    return _nelems;
  }

  size_t bufsize() const
  {
    return _bufsize;
  }

  auto extents() const {
    return _meta.extents();
  }
};

}  // namespace mephisto

#endif
