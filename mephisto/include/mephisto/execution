#ifndef MEPHISTO_EXECUTION_H
#define MEPHISTO_EXECUTION_H

#include <dash/Execution.h>
#include <libdash.h>
#include <alpaka/alpaka.hpp>
#include <memory>
#include <mephisto/algorithm/copy>
#include <mephisto/algorithm/for_each>
#include <mephisto/buffer>
#include <mephisto/util>

#include <mephisto/internal/logging.hpp>

namespace mephisto {
namespace execution {

template <typename F>
class Kernel {
  F _func;
public:

  Kernel(F func) : _func(func) {}

  ALPAKA_NO_HOST_ACC_WARNING
  template <typename TAcc, typename TElem, typename TRes, typename TIdx>
  ALPAKA_FN_ACC auto operator()(
      TAcc const & acc,
      const std::size_t block_index,
      TElem *const A,
      TRes *       res,
      TIdx const & numElements) const -> void
  {
    const uint32_t blockIndex(static_cast<uint32_t>(
        alpaka::idx::getIdx<alpaka::Grid, alpaka::Blocks>(acc)[0]));
    const uint32_t threadIndex(static_cast<uint32_t>(
        alpaka::idx::getIdx<alpaka::Block, alpaka::Threads>(acc)[0]));
    const uint32_t gridDimension(static_cast<uint32_t>(
        alpaka::workdiv::getWorkDiv<alpaka::Grid, alpaka::Blocks>(acc)[0]));
    const uint32_t threadElementExtent(static_cast<uint32_t>(
        alpaka::workdiv::getWorkDiv<alpaka::Thread, alpaka::Elems>(acc).prod()));

    const uint32_t i(static_cast<uint32_t>(
        alpaka::idx::getIdx<alpaka::Grid, alpaka::Threads>(acc)[0]));

    TIdx const threadFirstElemIdx(i * threadElementExtent);

    if (threadFirstElemIdx < numElements) {
      TIdx const threadLastElemIdx(threadFirstElemIdx + threadElementExtent);
      TIdx const threadLastElemIdxClipped(
          (numElements > threadLastElemIdx) ? threadLastElemIdx
                                            : numElements);
      for (TIdx a(threadFirstElemIdx); a < threadLastElemIdxClipped; ++a) {
        _func(i, a, res, A);
      }
    }
  }
};



/**
 * An executor that uses alpaka to do the work.
 */
template <class AlpakaContext>
struct AlpakaExecutor {
  AlpakaContext *ctx;

  // Wrapper entity
  using Entity = typename AlpakaContext::entity_t;
  // Alpaka entity/accelerator
  using Acc = typename Entity::acc_t;

  AlpakaExecutor(AlpakaContext *context)
    : ctx(context)
  {
  }

  template <
      class Function,
      class Shape,
      class ResultFactory,
      class SharedFactory>
  void bulk_twoway_execute(
      Function f, Shape iter, ResultFactory result_f, SharedFactory sf) const
  {
    auto &pattern = iter.pattern();

    initlog();

    using PatternT          = typename Shape::pattern_type;
    using value_type        = typename Shape::value_type;
    using dim               = alpaka::dim::DimInt<PatternT::ndim()>;
    using result_type       = typename std::result_of<ResultFactory()>::type;
    using result_value_t    = typename std::decay<result_type>::type::value_type;

    auto &      queue    = ctx->queue();
    auto &      result   = result_f();
    std::size_t block_nr = 0;

    // Assume we have a LocalPattern that lets us iterate over local blocks
    // for each accelerator
    auto host_result_view = alpaka::mem::view::createStaticDevMemView(
        ::mephisto::begin(result),
        alpaka::dev::DevCpu{
            alpaka::pltf::getDevByIdx<alpaka::pltf::PltfCpu>(0u)},
        ::mephisto::buf_size(result));
    for (auto const &entity : ctx->entities()) {
      auto result_buf = alpaka::mem::buf::alloc<result_value_t, std::size_t>(
          entity.device(), ::mephisto::buf_size(result));
      alpaka::mem::view::copy(
          queue, result_buf, host_result_view, mephisto::buf_size(result));
      for (auto &block : pattern.blocks_local_for_entity(entity)) {
        if (block.size() == 0) {
          continue;
        }
        // 1. create workdiv from block
        auto extents = alpaka::vec::createVecFromIndexedFnWorkaround<dim, std::size_t, arr_to_vec>(
            block.extents());
        auto thread_extent =
            alpaka::vec::createVecFromIndexedFnWorkaround<dim, std::size_t, unity_vec>(
                  static_cast<std::size_t>(block.size() / 4));

        auto offsets = block.offsets();

        alpaka::workdiv::WorkDivMembers<dim, std::size_t> const workDiv{
            alpaka::workdiv::getValidWorkDiv<Acc>(
                entity.device(), extents, thread_extent, false)};

        // 2. create host buffer
        auto block_begin =
            static_cast<typename Shape::pointer>(iter.globmem().begin()) +
            pattern.local_at(offsets);

        auto host_buf =
            mephisto::HostDataBuffer<value_type, Entity, PatternT::ndim()>{
                block, block_begin.local()};


        // 3. copy the buffer to the entity
        auto device_buf = mephisto::put(queue, host_buf, entity);

        // 4. work
        Kernel<Function> kernel(f);

        auto const taskKernel(alpaka::kernel::createTaskKernel<Acc>(
            workDiv,
            kernel,
            block_nr++,
            device_buf.begin(),
            alpaka::mem::view::getPtrNative(result_buf),
            block.size()));

        alpaka::queue::enqueue(queue, taskKernel);

        alpaka::mem::view::copy(
            queue,
            host_result_view,
            result_buf,
            ::mephisto::buf_size(result));
      }
    }
  }

  AlpakaContext &context() const
  {
    return ctx;
  }

  unsigned int concurrency() const {
    return Entity::total() * 4;
  }
};

template <class Entity, class Queue>
struct AlpakaExecutionContext {
  using host_t   = alpaka::dev::DevCpu;
  using entity_t = typename std::remove_cv<Entity>::type;
  using acc_t    = typename Entity::acc_t;

  host_t _host_device;
  Queue  _queue;

  AlpakaExecutionContext()
    : _host_device(alpaka::pltf::getDevByIdx<alpaka::pltf::PltfCpu>(0u))
#ifdef ALPAKA_ACC_GPU_CUDA_ENABLED
    , _queue(Entity{0}.device())
#else
    , _queue(_host_device)
#endif
  {
  }

  auto entities() const
  {
    return entity_t::all();
  }

  auto &queue()
  {
    return _queue;
  }
};

// See C++17's std::execution::par
// Additionally we enforce that the policy has an executor
template <class Executor>
struct ParallelPolicy {
  Executor ex;

  ParallelPolicy(Executor &&ex)
    : ex(ex)
  {
  }

  const Executor &executor() const
  {
    return ex;
  }
};

template <class Executor>
ParallelPolicy<Executor> make_parallel_policy(Executor &&ex)
{
  return ParallelPolicy<Executor>(ex);
}
}  // namespace execution
}  // namespace mephisto

namespace dash {

template <class Executor>
struct is_execution_policy<mephisto::execution::ParallelPolicy<Executor>>
  : public std::true_type {
};

}  // namespace dash

#endif
